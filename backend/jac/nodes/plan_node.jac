# =============================================================
# jac/nodes/plan_node.jac
#
# WHAT IT IS:
#   Holds the OSP (Object-Spatial Programming) mapping plan
#   generated by the PlannerWalker before conversion starts.
#   Think of it as the "architect's blueprint" â€” it tells the
#   ConverterWalker HOW to convert each file.
#
# WHY IT EXISTS:
#   Without a plan, each file would be converted in isolation.
#   With a plan, the ConverterWalker knows:
#     - Which Python class becomes which Jac node
#     - Which function flow becomes which Jac walker
#     - What edges (relationships) exist between nodes
#     - Which files to convert first (dependency order)
#
# HOW IT FITS:
#   RepoNode --[has_plan]--> PlanNode
#   ConverterWalker reads PlanNode before walking FileNodes
#
# USED BY:
#   - PlannerWalker  (creates and populates this node)
#   - ConverterWalker (reads mappings to guide code generation)
# =============================================================

node PlanNode {
    # Which Python classes map to which Jac nodes
    # e.g. [{"original_class": "User", "jac_node": "UserNode", "fields": ["id","name"]}]
    has node_mappings: list = [];

    # Which Python functions/classes map to which Jac walkers
    # e.g. [{"original": "create_user()", "jac_walker": "CreateUserWalker", "purpose": "creates a user"}]
    has walker_mappings: list = [];

    # What edges (relationships) exist between nodes
    # e.g. [{"from_node": "UserNode", "to_node": "OrderNode", "edge_name": "placed"}]
    has edge_mappings: list = [];

    # Files sorted so dependencies come first
    # e.g. ["models.py", "services.py", "routes.py"]
    # (models.py first because routes.py imports from it)
    has conversion_order: list = [];
}